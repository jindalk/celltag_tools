import os

import numpy as np
import pandas as pd
import scipy

from .celltag_data import CellTagData, celltag_mtx_dict
from .utils import (call_clones_util, check_mtx_dict, jaccard_similarities,
                    table_to_spmtx)


def read_celltag(
    celltag_path,
    sample_prefix=None,
    assay="RNA",
    triplet_th=1,
    starcode_th=2,
    starcode_path=None,
    allowlist_path=None,
    inplace=True,
):
    """
    Reads and processes CellTag read data from file paths, applying
    filtering, error correction, and allowlisting. Optionally returns a new
    CellTagData object or the processed data.

    Args:
        celltag_path (str | list[str]):
            Path or list of paths to the CellTag read files (TSV format).
        sample_prefix (str | list[str], optional):
            Prefix or list of prefixes to be added to CellTag barcodes. If not provided
            and multiple paths are specified, prefixes are autogenerated.
        assay (str, optional):
            Single-cell assay type. Must be either "RNA" or "ATAC". Defaults to "RNA".
        triplet_th (int, optional):
            Threshold for filtering out read triplets (UMI or read occurrences)
            below this count. Defaults to 1.
        starcode_th (int, optional):
            Edit distance threshold for collapsing barcodes via Starcode. Defaults to 2.
        starcode_path (str, optional):
            Path to the Starcode installation directory. Must contain the executable 'starcode'.
        allowlist_path (str, optional):
            Path to the allowlist file (TSV) containing valid CellTags.
        inplace (bool, optional):
            If True, returns a CellTagData object with the processed data set inside it.
            If False, returns a tuple containing (processed reads, thresholds, sequencing saturation).
            Defaults to True.

    Returns:
        CellTagData:
            If `inplace=True`, returns a CellTagData object with ct_reads, thresholds, and seq_sat set.
        tuple:
            If `inplace=False`, returns a tuple of:
                - pd.DataFrame: Processed CellTag read data.
                - dict: Dictionary containing thresholds {'starcode': starcode_th, 'triplet': triplet_th}.
                - float: Sequencing saturation percentage.

    Raises:
        ValueError: If any of the provided file paths do not exist, if Starcode is not found,
            if the allowlist is missing, or if `assay` is invalid ("RNA" or "ATAC" only).
    """


    # check assay
    if not isinstance(assay, str):
        raise ValueError("Assay name should be a string")

    # check starcode
    if not os.path.exists(f"{starcode_path}/starcode"):
        raise ValueError(
            "Starcode path does not exist, please check if starcode is installed correctly"
        )

    # check allowlist
    if not os.path.exists(allowlist_path):
        raise ValueError("Allowlist path does not exist")

    assay = assay.upper()
    if assay != "RNA" and assay != "ATAC":
        raise ValueError("Assay should be either RNA or ATAC")

    # harmonize everything into lists
    if not isinstance(celltag_path, list):
        celltag_path = [celltag_path]

    if not all(os.path.exists(p) for p in celltag_path):
        raise ValueError("Not all paths are valid")

    # check sample prefixes are valid, if specified
    if sample_prefix != None:
        if not isinstance(sample_prefix, list):
            sample_prefix = [sample_prefix]
            if len(sample_prefix) != len(celltag_path):
                raise ValueError(
                    "Number of sample prefixes specified is different from number of celltag read files"
                )

    # generate prefixes if needed
    if sample_prefix is None:
        if len(celltag_path) > 1:
            print("Autogenerating sample prefixes")
            sample_prefix = [f"sample_{i+1}-" for i in range(len(celltag_path))]
        elif len(celltag_path) == 1:
            sample_prefix = [""]

    # ensure these are strings
    sample_prefix = [str(x) for x in sample_prefix]

    # read celltag read files
    ct_reads_list = []

    # import and filter celltag table from each file and add to list
    for path_curr, pre_curr in zip(celltag_path, sample_prefix):

        print(f"processing: {path_curr}")
        bam_fil = pd.read_csv(path_curr, sep="\t")
        print(f"Total filtered CellTag Reads: {len(bam_fil)}")

        # create UMI counts per CB-celltag pair
        if assay == "RNA":
            bam_fil["concat"] = (
                bam_fil["Cell.BC"] + "." + bam_fil["Cell.Tag"] + "." + bam_fil["UMI"]
            )
        else:
            bam_fil["concat"] = bam_fil["Cell.BC"] + "." + bam_fil["Cell.Tag"]

        # filter triplets on read counts
        reads, counts = np.unique(bam_fil["concat"].values, return_counts=True)
        bam_umi = pd.DataFrame(reads[(counts > triplet_th)])

        # calculate sequencing saturation
        seq_sat = 100 * (1 - len(reads[(counts == 1)]) / len(bam_fil))
        print("CellTag Sequencing saturation: ", str(seq_sat))

        bam_umi["Cell.BC"] = bam_umi[0].apply(lambda x: str(x).split(".")[0])
        bam_umi["Cell.Tag"] = bam_umi[0].apply(lambda x: str(x).split(".")[1])
        bam_umi.drop(columns=0, inplace=True)
        del bam_fil

        # perform error correction with starcode
        (bam_umi["Cell.BC"].apply(lambda x: x[:-2]) + bam_umi["Cell.Tag"]).to_csv(
            "ct_collapsing.txt", sep="\t", index=False, header=False
        )

        os.system(
            f"{starcode_path}/starcode -t 4 -d {starcode_th} -s ct_collapsing.txt > ct_collapsing_result.txt"
        )
        ct_reads_final = pd.read_csv("ct_collapsing_result.txt", sep="\t", header=None)
        ct_reads_final["CB"] = ct_reads_final[0].apply(lambda x: x[:16] + "-1")
        ct_reads_final["celltag"] = ct_reads_final[0].apply(lambda x: x[16:])
        ct_reads_final.rename(columns={1: "count"}, inplace=True)
        ct_reads_final.drop(columns=[0], inplace=True)
        os.system("rm ct_collapsing_result.txt")
        os.system("rm ct_collapsing.txt")

        # allowlisting
        allow = pd.read_csv(allowlist_path, header=None)
        ct_reads_final = ct_reads_final[ct_reads_final["celltag"].isin(allow[0])].copy()
        ct_reads_final["CB"] = pre_curr + ct_reads_final["CB"]
        ct_reads_list.append(ct_reads_final)

    ct_reads_merged = pd.concat(ct_reads_list)

    # create thresholds dict
    th = {"starcode": starcode_th, "triplet": triplet_th}

    if inplace:
        print(
            "Creating CellTagData object and setting ct_reads, thresholds, and seq_sat"
        )
        celltag_obj = CellTagData(
            ct_reads=ct_reads_merged, thresholds=th, seq_sat=seq_sat
        )
        return celltag_obj

    else:
        return (ct_reads_merged, th, seq_sat)


def create_allow_mtx(ct_obj, overwrite=False, inplace=True):
    """Creates a sparse allow matrix (cell x CellTag) in the provided
    CellTagData object, using either UMI counts (for RNA) or read counts (for
    ATAC).

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing the 'ct_reads' attribute.
        overwrite (bool, optional):
            If False (default), raises an error if an allow matrix already exists.
            If True, overwrites the existing allow matrix.
        inplace (bool, optional):
            If True (default), updates the allow_mtx attribute within the ct_obj.
            If False, returns the created allow matrix and associated row/column labels.

    Returns:
        tuple:
            If `inplace=False`, returns (allow_mtx, allow_rows, allow_cols), where:
                - allow_mtx (scipy.sparse.csr_matrix): The constructed allow matrix.
                - allow_rows (list): List of cell barcodes (rows).
                - allow_cols (list): List of allowed CellTags (columns).

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object or if the allow matrix already exists
            and `overwrite=False`.
    """
    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    if (not ct_obj.allow_mtx.is_empty()) and overwrite == False:
        raise ValueError(
            "Allow matrix already filled, set overwrite to True to force re-assignment"
        )

    allow_mtx, allow_rows, allow_cols = table_to_spmtx(
        ct_obj.ct_reads["CB"],
        ct_obj.ct_reads["celltag"],
        count_data=ct_obj.ct_reads["count"],
    )

    if inplace:
        ct_obj.allow_mtx["mtx"] = allow_mtx
        ct_obj.allow_mtx["cells"] = allow_rows
        ct_obj.allow_mtx["celltags"] = allow_cols

    else:
        return (allow_mtx, allow_rows, allow_cols)


def create_bin_mtx(ct_obj, bin_th=1, overwrite=False, inplace=True):
    """Binarizes the allow matrix from a CellTagData object. The resulting
    matrix is stored in bin_mtx if 'inplace=True', or returned. Values above
    `bin_th` are set to True (1), else False (0).

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing an allow matrix in allow_mtx.
        bin_th (int, optional):
            Threshold for binarization. Defaults to 1.
        overwrite (bool, optional):
            If False (default), raises an error if a binarized matrix already exists.
            If True, overwrites the existing bin_mtx.
        inplace (bool, optional):
            If True (default), updates bin_mtx attribute within ct_obj.
            If False, returns the binarized matrix and associated row/column labels.

    Returns:
        tuple:
            If `inplace=False`, returns (ct_bin_mtx, cells, celltags), where:
                - ct_bin_mtx (scipy.sparse.csr_matrix): The binarized matrix.
                - cells (list): List of cell barcodes (rows).
                - celltags (list): List of CellTags (columns).

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object or if the allow_mtx is missing/invalid,
            or if a binarized matrix already exists and `overwrite=False`.
    """

    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    check_mtx_dict(ct_obj.allow_mtx)

    if (not ct_obj.bin_mtx.is_empty()) and overwrite == False:
        raise ValueError(
            "Binarized matrix already filled, set overwrite to True to force re-assignment"
        )

    # binarize
    ct_bin_mtx = ct_obj.allow_mtx["mtx"].copy()
    ct_bin_mtx = ct_bin_mtx > bin_th

    if inplace:
        ct_obj.bin_mtx["mtx"] = ct_bin_mtx
        ct_obj.bin_mtx["cells"] = ct_obj.allow_mtx["cells"].copy()
        ct_obj.bin_mtx["celltags"] = ct_obj.allow_mtx["celltags"].copy()
        ct_obj.thresholds["binarization"] = bin_th

    else:
        return (
            ct_bin_mtx,
            ct_obj.allow_mtx["cells"].copy(),
            ct_obj.allow_mtx["celltags"].copy(),
        )


def create_metric_mtx(ct_obj, met_lower=1, met_upper=25, overwrite=False, inplace=True):
    """Performs metric-based filtering on the binarized cell x CellTag matrix
    to remove cells with too few or too many CellTags (defined by met_lower and
    met_upper). Produces a filtered matrix stored in metric_mtx if
    'inplace=True', or returns it.

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing a binarized matrix in bin_mtx.
        met_lower (int, optional):
            Minimum number of CellTags required for a cell to be retained. Defaults to 1.
        met_upper (int, optional):
            Maximum number of CellTags allowed for a cell to be retained. Defaults to 25.
        overwrite (bool, optional):
            If False (default), raises an error if a metric matrix already exists.
            If True, overwrites the existing metric_mtx.
        inplace (bool, optional):
            If True (default), updates metric_mtx attribute within ct_obj.
            If False, returns the filtered matrix and associated row/column labels.

    Returns:
        tuple:
            If `inplace=False`, returns (celltag_mat_met, cells_met, celltags_met), where:
                - celltag_mat_met (scipy.sparse.csr_matrix): The filtered (metric) matrix.
                - cells_met (ndarray): Array of filtered cell barcodes (rows).
                - celltags_met (ndarray): Array of filtered CellTags (columns).

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object, if bin_mtx is missing/invalid,
            or if a metric matrix already exists and `overwrite=False`.
    """

    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    # check if binary mtx is properly formatted
    check_mtx_dict(ct_obj.bin_mtx)

    if (not ct_obj.metric_mtx.is_empty()) and overwrite == False:
        raise ValueError(
            "Metric matrix already filled, set overwrite to True to force re-assignment"
        )

    # metric filter
    celltag_mat_bin = ct_obj.bin_mtx["mtx"].copy()
    cells = ct_obj.bin_mtx["cells"].copy()
    celltags = ct_obj.bin_mtx["celltags"].copy()

    print(f"Using {met_lower} as lower and {met_upper} as upper thresholds")
    row_fil = (celltag_mat_bin.sum(axis=1) > met_lower) & (
        celltag_mat_bin.sum(axis=1) < met_upper
    )
    temp = celltag_mat_bin[row_fil.nonzero()[0],]
    col_fil = temp.sum(axis=0) > 0
    celltag_mat_met = temp[:, col_fil.nonzero()[1]].copy()
    celltag_mat_met = celltag_mat_met * 1

    cells_met = np.array(cells)[row_fil.nonzero()[0]]
    celltags_met = np.array(celltags)[col_fil.nonzero()[1]]

    if inplace:
        ct_obj.metric_mtx["mtx"] = celltag_mat_met
        ct_obj.metric_mtx["cells"] = cells_met
        ct_obj.metric_mtx["celltags"] = celltags_met
        ct_obj.thresholds["metric_lower"] = met_lower
        ct_obj.thresholds["metric_upper"] = met_upper

    else:
        return (celltag_mat_met, cells_met, celltags_met)


def call_clones(
    ct_obj, jaccard_th=0.7, return_graph=False, overwrite=False, inplace=True
):
    """Identifies clonal relationships among cells based on the Jaccard
    similarity of their CellTag profiles. Optionally returns the Jaccard
    matrix, a graph representation, and a clone table, or stores them within
    the given CellTagData object.

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing a filtered matrix in metric_mtx.
        jaccard_th (float, optional):
            Threshold for Jaccard similarity to consider cells part of the same clone.
            Defaults to 0.7.
        return_graph (bool, optional):
            If True, additionally returns the graph representation of cell clones.
            Defaults to False.
        overwrite (bool, optional):
            If False (default), raises an error if the Jaccard matrix or clone table
            already exist. If True, overwrites existing data.
        inplace (bool, optional):
            If True (default), updates the ct_obj with jaccard_mtx, clone_table,
            and optionally clone_graph if `return_graph=True`.
            If False, returns the requested data.

    Returns:
        tuple:
            Depending on `inplace` and `return_graph`:
                - If `inplace=False` and `return_graph=False`: (jac_mat, clones).
                - If `inplace=False` and `return_graph=True`: (jac_mat, clone_graph, clones).
            Where:
                - jac_mat (scipy.sparse.csr_matrix): Jaccard similarity matrix.
                - clone_graph (networkx.Graph): Graph where nodes represent cells,
                  and edges represent similarity > jaccard_th.
                - clones (pd.DataFrame): Table mapping cells to their assigned clones.

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object, if metric_mtx is missing/invalid,
            or if jaccard_mtx or clone_table already exist and `overwrite=False`.
    """


    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    # check if metric mtx is properly formatted
    check_mtx_dict(ct_obj.metric_mtx)

    if not (ct_obj.jaccard_mtx == None) and overwrite == False:
        raise ValueError(
            "Jaccard similarities matrix already exists, set overwrite to True to force re-assignment"
        )

    if not (ct_obj.clone_table == None) and overwrite == False:
        raise ValueError(
            "Clone table already exists, set overwrite to True to force re-assignment"
        )

    print("Calculating Jaccard similarity")
    jac_mat = jaccard_similarities(
        ct_obj.metric_mtx["mtx"].tocsc().astype(np.float64).transpose()
    )
    jac_mat.setdiag(0)

    print("Identifying clones")

    # run clone calling
    cells_met = ct_obj.metric_mtx["cells"].copy()

    clone_res = call_clones_util(
        scipy.sparse.tril(jac_mat),
        cells_met,
        jac_th=jaccard_th,
        return_graph=return_graph,
    )

    if return_graph:
        g = clone_res[0].copy()
        clones = clone_res[1].copy()
    else:
        clones = clone_res.copy()

    if inplace:
        if return_graph:
            ct_obj.jaccard_mtx = jac_mat.copy()
            ct_obj.clone_graph = g.copy()
            ct_obj.clone_table = clones.copy()
            ct_obj.thresholds["jaccard"] = jaccard_th

        else:
            ct_obj.jaccard_mtx = jac_mat.copy()
            ct_obj.clone_table = clones.copy()
            ct_obj.thresholds["jaccard"] = jaccard_th

    else:
        if return_graph:
            return (jac_mat.copy(), g.copy(), clones.copy())

        else:
            return (jac_mat.copy(), clones.copy())
