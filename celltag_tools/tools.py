import os

import numpy as np
import pandas as pd
import scipy

from .celltag_data import CellTagData, celltag_mtx_dict
from .utils import (_call_clones_util, check_mtx_dict, jaccard_similarities,
                    table_to_spmtx, _assign_fate_util)


def read_celltag(
    celltag_path,
    sample_prefix=None,
    assay="RNA",
    triplet_th=1,
    starcode_th=2,
    starcode_path=None,
    allowlist_path=None,
    inplace=True,
):
    """
    Reads and processes CellTag read data from file paths, applying
    filtering, error correction, and allowlisting. Optionally returns a new
    CellTagData object or the processed data.

    Args:
        celltag_path (str | list[str]):
            Path or list of paths to the CellTag read files (TSV format).
        sample_prefix (str | list[str], optional):
            Prefix or list of prefixes to be added to CellTag barcodes. If not provided
            and multiple paths are specified, prefixes are autogenerated.
        assay (str, optional):
            Single-cell assay type. Must be either "RNA" or "ATAC". Defaults to "RNA".
        triplet_th (int, optional):
            Threshold for filtering out read triplets (UMI or read occurrences)
            below this count. Defaults to 1.
        starcode_th (int, optional):
            Edit distance threshold for collapsing barcodes via Starcode. Defaults to 2.
        starcode_path (str, optional):
            Path to the Starcode installation directory. Must contain the executable 'starcode'.
        allowlist_path (str, optional):
            Path to the allowlist file (TSV) containing valid CellTags.
        inplace (bool, optional):
            If True, returns a CellTagData object with the processed data set inside it.
            If False, returns a tuple containing (processed reads, thresholds, sequencing saturation).
            Defaults to True.

    Returns:
        CellTagData:
            If `inplace=True`, returns a CellTagData object with ct_reads, thresholds, and seq_sat set.
        tuple:
            If `inplace=False`, returns a tuple of:
                - pd.DataFrame: Processed CellTag read data.
                - dict: Dictionary containing thresholds {'starcode': starcode_th, 'triplet': triplet_th}.
                - float: Sequencing saturation percentage.

    Raises:
        ValueError: If any of the provided file paths do not exist, if Starcode is not found,
            if the allowlist is missing, or if `assay` is invalid ("RNA" or "ATAC" only).
    """


    # check assay
    if not isinstance(assay, str):
        raise ValueError("Assay name should be a string")

    # check starcode
    if not os.path.exists(f"{starcode_path}/starcode"):
        raise ValueError(
            "Starcode path does not exist, please check if starcode is installed correctly"
        )

    # check allowlist
    if not os.path.exists(allowlist_path):
        raise ValueError("Allowlist path does not exist")

    assay = assay.upper()
    if assay != "RNA" and assay != "ATAC":
        raise ValueError("Assay should be either RNA or ATAC")

    # harmonize everything into lists
    if not isinstance(celltag_path, list):
        celltag_path = [celltag_path]

    if not all(os.path.exists(p) for p in celltag_path):
        raise ValueError("Not all paths are valid")

    # check sample prefixes are valid, if specified
    if sample_prefix != None:
        if not isinstance(sample_prefix, list):
            sample_prefix = [sample_prefix]
            if len(sample_prefix) != len(celltag_path):
                raise ValueError(
                    "Number of sample prefixes specified is different from number of celltag read files"
                )

    # generate prefixes if needed
    if sample_prefix is None:
        if len(celltag_path) > 1:
            print("Autogenerating sample prefixes")
            sample_prefix = [f"sample_{i+1}-" for i in range(len(celltag_path))]
        elif len(celltag_path) == 1:
            sample_prefix = [""]

    # ensure these are strings
    sample_prefix = [str(x) for x in sample_prefix]

    # read celltag read files
    ct_reads_list = []

    # import and filter celltag table from each file and add to list
    for path_curr, pre_curr in zip(celltag_path, sample_prefix):

        print(f"processing: {path_curr}")
        bam_fil = pd.read_csv(path_curr, sep="\t")
        print(f"Total filtered CellTag Reads: {len(bam_fil)}")

        # create UMI counts per CB-celltag pair
        if assay == "RNA":
            bam_fil["concat"] = (
                bam_fil["Cell.BC"] + "." + bam_fil["Cell.Tag"] + "." + bam_fil["UMI"]
            )
        else:
            bam_fil["concat"] = bam_fil["Cell.BC"] + "." + bam_fil["Cell.Tag"]

        # filter triplets on read counts
        reads, counts = np.unique(bam_fil["concat"].values, return_counts=True)
        bam_umi = pd.DataFrame(reads[(counts > triplet_th)])

        # calculate sequencing saturation
        seq_sat = 100 * (1 - len(reads[(counts == 1)]) / len(bam_fil))
        print("CellTag Sequencing saturation: ", str(seq_sat))

        bam_umi["Cell.BC"] = bam_umi[0].apply(lambda x: str(x).split(".")[0])
        bam_umi["Cell.Tag"] = bam_umi[0].apply(lambda x: str(x).split(".")[1])
        bam_umi.drop(columns=0, inplace=True)
        del bam_fil

        # perform error correction with starcode
        (bam_umi["Cell.BC"].apply(lambda x: x[:-2]) + bam_umi["Cell.Tag"]).to_csv(
            "ct_collapsing.txt", sep="\t", index=False, header=False
        )

        os.system(
            f"{starcode_path}/starcode -t 4 -d {starcode_th} -s ct_collapsing.txt > ct_collapsing_result.txt"
        )
        ct_reads_final = pd.read_csv("ct_collapsing_result.txt", sep="\t", header=None)
        ct_reads_final["CB"] = ct_reads_final[0].apply(lambda x: x[:16] + "-1")
        ct_reads_final["celltag"] = ct_reads_final[0].apply(lambda x: x[16:])
        ct_reads_final.rename(columns={1: "count"}, inplace=True)
        ct_reads_final.drop(columns=[0], inplace=True)
        os.system("rm ct_collapsing_result.txt")
        os.system("rm ct_collapsing.txt")

        # allowlisting
        allow = pd.read_csv(allowlist_path, header=None)
        ct_reads_final = ct_reads_final[ct_reads_final["celltag"].isin(allow[0])].copy()
        ct_reads_final["CB"] = pre_curr + ct_reads_final["CB"]
        ct_reads_list.append(ct_reads_final)

    ct_reads_merged = pd.concat(ct_reads_list)

    # create thresholds dict
    th = {"starcode": starcode_th, "triplet": triplet_th}

    if inplace:
        print(
            "Creating CellTagData object and setting ct_reads, thresholds, and seq_sat"
        )
        celltag_obj = CellTagData(
            ct_reads=ct_reads_merged, thresholds=th, seq_sat=seq_sat
        )
        return celltag_obj

    else:
        return (ct_reads_merged, th, seq_sat)


def create_allow_mtx(ct_obj, overwrite=False, inplace=True):
    """Creates a sparse allow matrix (cell x CellTag) in the provided
    CellTagData object, using either UMI counts (for RNA) or read counts (for
    ATAC).

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing the 'ct_reads' attribute.
        overwrite (bool, optional):
            If False (default), raises an error if an allow matrix already exists.
            If True, overwrites the existing allow matrix.
        inplace (bool, optional):
            If True (default), updates the allow_mtx attribute within the ct_obj.
            If False, returns the created allow matrix and associated row/column labels.

    Returns:
        tuple:
            If `inplace=False`, returns (allow_mtx, allow_rows, allow_cols), where:
                - allow_mtx (scipy.sparse.csr_matrix): The constructed allow matrix.
                - allow_rows (list): List of cell barcodes (rows).
                - allow_cols (list): List of allowed CellTags (columns).

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object or if the allow matrix already exists
            and `overwrite=False`.
    """
    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    if (not ct_obj.allow_mtx.is_empty()) and overwrite == False:
        raise ValueError(
            "Allow matrix already filled, set overwrite to True to force re-assignment"
        )

    allow_mtx, allow_rows, allow_cols = table_to_spmtx(
        ct_obj.ct_reads["CB"],
        ct_obj.ct_reads["celltag"],
        count_data=ct_obj.ct_reads["count"],
    )

    if inplace:
        ct_obj.allow_mtx["mtx"] = allow_mtx
        ct_obj.allow_mtx["cells"] = allow_rows
        ct_obj.allow_mtx["celltags"] = allow_cols

    else:
        return (allow_mtx, allow_rows, allow_cols)


def create_bin_mtx(ct_obj, bin_th=1, overwrite=False, inplace=True):
    """Binarizes the allow matrix from a CellTagData object. The resulting
    matrix is stored in bin_mtx if 'inplace=True', or returned. Values above
    `bin_th` are set to True (1), else False (0).

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing an allow matrix in allow_mtx.
        bin_th (int, optional):
            Threshold for binarization. Defaults to 1.
        overwrite (bool, optional):
            If False (default), raises an error if a binarized matrix already exists.
            If True, overwrites the existing bin_mtx.
        inplace (bool, optional):
            If True (default), updates bin_mtx attribute within ct_obj.
            If False, returns the binarized matrix and associated row/column labels.

    Returns:
        tuple:
            If `inplace=False`, returns (ct_bin_mtx, cells, celltags), where:
                - ct_bin_mtx (scipy.sparse.csr_matrix): The binarized matrix.
                - cells (list): List of cell barcodes (rows).
                - celltags (list): List of CellTags (columns).

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object or if the allow_mtx is missing/invalid,
            or if a binarized matrix already exists and `overwrite=False`.
    """

    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    check_mtx_dict(ct_obj.allow_mtx)

    if (not ct_obj.bin_mtx.is_empty()) and overwrite == False:
        raise ValueError(
            "Binarized matrix already filled, set overwrite to True to force re-assignment"
        )

    # binarize
    ct_bin_mtx = ct_obj.allow_mtx["mtx"].copy()
    ct_bin_mtx = ct_bin_mtx > bin_th

    if inplace:
        ct_obj.bin_mtx["mtx"] = ct_bin_mtx
        ct_obj.bin_mtx["cells"] = ct_obj.allow_mtx["cells"].copy()
        ct_obj.bin_mtx["celltags"] = ct_obj.allow_mtx["celltags"].copy()
        ct_obj.thresholds["binarization"] = bin_th

    else:
        return (
            ct_bin_mtx,
            ct_obj.allow_mtx["cells"].copy(),
            ct_obj.allow_mtx["celltags"].copy(),
        )


def create_metric_mtx(ct_obj, met_lower=1, met_upper=25, overwrite=False, inplace=True):
    """Performs metric-based filtering on the binarized cell x CellTag matrix
    to remove cells with too few or too many CellTags (defined by met_lower and
    met_upper). Produces a filtered matrix stored in metric_mtx if
    'inplace=True', or returns it.

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing a binarized matrix in bin_mtx.
        met_lower (int, optional):
            Minimum number of CellTags required for a cell to be retained. Defaults to 1.
        met_upper (int, optional):
            Maximum number of CellTags allowed for a cell to be retained. Defaults to 25.
        overwrite (bool, optional):
            If False (default), raises an error if a metric matrix already exists.
            If True, overwrites the existing metric_mtx.
        inplace (bool, optional):
            If True (default), updates metric_mtx attribute within ct_obj.
            If False, returns the filtered matrix and associated row/column labels.

    Returns:
        tuple:
            If `inplace=False`, returns (celltag_mat_met, cells_met, celltags_met), where:
                - celltag_mat_met (scipy.sparse.csr_matrix): The filtered (metric) matrix.
                - cells_met (ndarray): Array of filtered cell barcodes (rows).
                - celltags_met (ndarray): Array of filtered CellTags (columns).

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object, if bin_mtx is missing/invalid,
            or if a metric matrix already exists and `overwrite=False`.
    """

    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    # check if binary mtx is properly formatted
    check_mtx_dict(ct_obj.bin_mtx)

    if (not ct_obj.metric_mtx.is_empty()) and overwrite == False:
        raise ValueError(
            "Metric matrix already filled, set overwrite to True to force re-assignment"
        )

    # metric filter
    celltag_mat_bin = ct_obj.bin_mtx["mtx"].copy()
    cells = ct_obj.bin_mtx["cells"].copy()
    celltags = ct_obj.bin_mtx["celltags"].copy()

    print(f"Using {met_lower} as lower and {met_upper} as upper thresholds")
    row_fil = (celltag_mat_bin.sum(axis=1) > met_lower) & (
        celltag_mat_bin.sum(axis=1) < met_upper
    )
    temp = celltag_mat_bin[row_fil.nonzero()[0],]
    col_fil = temp.sum(axis=0) > 0
    celltag_mat_met = temp[:, col_fil.nonzero()[1]].copy()
    celltag_mat_met = celltag_mat_met * 1

    cells_met = np.array(cells)[row_fil.nonzero()[0]]
    celltags_met = np.array(celltags)[col_fil.nonzero()[1]]

    if inplace:
        ct_obj.metric_mtx["mtx"] = celltag_mat_met
        ct_obj.metric_mtx["cells"] = cells_met
        ct_obj.metric_mtx["celltags"] = celltags_met
        ct_obj.thresholds["metric_lower"] = met_lower
        ct_obj.thresholds["metric_upper"] = met_upper

    else:
        return (celltag_mat_met, cells_met, celltags_met)


def call_clones(
    ct_obj, jaccard_th=0.7, return_graph=False, overwrite=False, inplace=True
):
    """Identifies clonal relationships among cells based on the Jaccard
    similarity of their CellTag profiles. Optionally returns the Jaccard
    matrix, a graph representation, and a clone table, or stores them within
    the given CellTagData object.

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing a filtered matrix in metric_mtx.
        jaccard_th (float, optional):
            Threshold for Jaccard similarity to consider cells part of the same clone.
            Defaults to 0.7.
        return_graph (bool, optional):
            If True, additionally returns the graph representation of cell clones.
            Defaults to False.
        overwrite (bool, optional):
            If False (default), raises an error if the Jaccard matrix or clone table
            already exist. If True, overwrites existing data.
        inplace (bool, optional):
            If True (default), updates the ct_obj with jaccard_mtx, clone_table,
            and optionally clone_graph if `return_graph=True`.
            If False, returns the requested data.

    Returns:
        tuple | None:
            Depending on `inplace` and `return_graph`:
                - If `inplace=False` and `return_graph=False`: (jac_mat, clones).
                - If `inplace=False` and `return_graph=True`: (jac_mat, clone_graph, clones).
                - If `inplace=True function sets the following attributes on the CellTagData object:
                    - ct_obj.jaccard_mtx
                    - ct_obj.clone_table
                    - ct_obj.thresholds["jaccard"]
                    - ct_obj.clone_graph (only if `return_graph=True`)
            Where:
                - jac_mat (scipy.sparse.csr_matrix): Jaccard similarity matrix.
                - clone_graph (networkx.Graph): Graph where nodes represent cells,
                  and edges represent similarity > jaccard_th.
                - clones (pd.DataFrame): Table mapping cells to their assigned clones.

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object, if metric_mtx is missing/invalid,
            or if jaccard_mtx or clone_table already exist and `overwrite=False`.
    """


    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    # check if metric mtx is properly formatted
    check_mtx_dict(ct_obj.metric_mtx)

    if not (ct_obj.jaccard_mtx == None) and overwrite == False:
        raise ValueError(
            "Jaccard similarities matrix already exists, set overwrite to True to force re-assignment"
        )

    if not (ct_obj.clone_table == None) and overwrite == False:
        raise ValueError(
            "Clone table already exists, set overwrite to True to force re-assignment"
        )

    print("Calculating Jaccard similarity")
    jac_mat = jaccard_similarities(
        ct_obj.metric_mtx["mtx"].tocsc().astype(np.float64).transpose()
    )
    jac_mat.setdiag(0)

    print("Identifying clones")

    # run clone calling
    cells_met = ct_obj.metric_mtx["cells"].copy()

    clone_res = _call_clones_util(
        scipy.sparse.tril(jac_mat),
        cells_met,
        jac_th=jaccard_th,
        return_graph=return_graph,
    )

    if return_graph:
        g = clone_res[0].copy()
        clones = clone_res[1].copy()
    else:
        clones = clone_res.copy()

    if inplace:
        if return_graph:
            ct_obj.jaccard_mtx = jac_mat.copy()
            ct_obj.clone_graph = g.copy()
            ct_obj.clone_table = clones.copy()
            ct_obj.thresholds["jaccard"] = jaccard_th

        else:
            ct_obj.jaccard_mtx = jac_mat.copy()
            ct_obj.clone_table = clones.copy()
            ct_obj.thresholds["jaccard"] = jaccard_th

    else:
        if return_graph:
            return (jac_mat.copy(), g.copy(), clones.copy())

        else:
            return (jac_mat.copy(), clones.copy())

def assign_fate(ct_obj, fate_col = 'day', fate_key='d5', cell_type_key = 'cell_type2', inplace=False):
    
    """
    Assigns a "fate" to each clone in a CellTagData object's clone table, based on
    the most frequent cell type (`cell_type_key`) present at a specified time point
    (`fate_key` in column `fate_col`).

    For each clone (identified by `clone.id`), the function finds rows in the clone
    table where `fate_col == fate_key` and determines the most common `cell_type_key`
    among those rows. This value is assigned as the clone's "fate," along with the
    percentage of cells (`fate_pct`) that match this fate within that clone at
    `fate_key`. If no cells meet the fate criteria (e.g., time point is missing), the
    clone is labeled with `fate='no_fate_cells'` and `fate_pct=0`.

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing `clone_table`.
        fate_col (str, optional):
            Column name in `clone_table` that defines the time point or condition
            used to assign fate. Defaults to `'day'`.
        fate_key (str, optional):
            A value in `fate_col` specifying which rows represent the "fate" condition.
            Defaults to `'d5'`.
        cell_type_key (str, optional):
            Column name in `clone_table` that specifies the cell type. Defaults to
            `'cell_type2'`.
        inplace (bool, optional):
            If `True`, updates `ct_obj.clone_table` directly. If `False` (default),
            returns a modified DataFrame without changing `ct_obj`.

    Returns:
        pandas.DataFrame | None:
            - If `inplace=False`, returns the updated clone table with new columns
              `fate` and `fate_pct`.
            - If `inplace=True`, the function returns `None` and updates
              `ct_obj.clone_table` in place.

    Raises:
        ValueError: If `ct_obj` is not a CellTagData object, if `clone_table` is missing
            or invalid, or if the specified columns (`fate_col`, `cell_type_key`) are
            not found in the table.
    """

    #checks
    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    if not (isinstance(ct_obj.clone_table, pd.DataFrame)):
        raise ValueError("Clone table is either not available or not a DataFrame, please re-run tl.call_clones") 
    
    clone_table = ct_obj.clone_table.copy()

    if not fate_col in clone_table.columns:
        raise ValueError(f"{fate_col} is not a valid column in the clone_table")
        
    if not cell_type_key in clone_table.columns:
        raise ValueError(f"{cell_type_key} is not a valid column in the clone_table")
        

    new_table = pd.DataFrame()

    for _,i in clone_table.groupby("clone.id"):
        clone_curr = _assign_fate_util(i, fate_col = 'day', fate_key='d5', cell_type_key = 'cell_type2')
        new_table = pd.concat((new_table,clone_curr))

    if(inplace):
        ct_obj.clone_table = new_table.copy()
        
    else:
        return new_table.copy()
    
def naive_atac_rna_pairing(ct_obj, seed = 100, state_day = None, add_fate=True):
    """
    Performs a naive pairing of cells labeled as ATAC with those labeled as RNA within
    the same clone, using `clone_table` of a CellTagData object. Random pairing is done so that every
    ATAC sibling is matched to an RNA sibling, potentially looping over if the sets differ
    in size.

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object containing `clone_table`.
        seed (int, optional):
            Seed value for NumPy's random generator to ensure reproducible pairings.
            Defaults to 100.
        state_day (str | None, optional):
            If provided, restricts the pairing to cells in the `clone_table` where
            `'day' == state_day`. Defaults to None.
        add_fate (bool, optional):
            If True, attempts to append an additional row containing the `fate`
            value for all paired cells. The column `'fate'` must exist in `clone_table`.
            Defaults to True.

    Returns:
        numpy.ndarray:
            A 2D array of shape (2, N) or (3, N), where N is the total number of pairs.
            - First row: ATAC cell barcodes
            - Second row: RNA cell barcodes
            - Third row (optional): The single fate value repeated for each pair
              (only if `add_fate` is True and `'fate'` column exists).

    Raises:
        ValueError: If `ct_obj` is invalid, if `clone_table` is missing or not a DataFrame,
            or if `add_fate=True` but `'fate'` column is missing.
    """

    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    if not isinstance(ct_obj.clone_table, pd.DataFrame):
        raise ValueError("Clone table is either not available or not a DataFrame, please re-run tl.call_clones")

    clone  = ct_obj.clone_table.copy()
    
    np.random.seed(seed)

    if(state_day is not None):
        print("state_day has been provided, performing RNA-ATAC pairing only within the state day.")
        state_clone = clone[clone['day'] == 'd2'].copy(deep=True)
    else:
        state_clone = clone.copy()
        
    atac_cells = state_clone[state_clone['assay'] == 'atac']['cell.barcode'].values
    rna_cells = state_clone[state_clone['assay'] == 'rna']['cell.barcode'].values
    
    atac_len = len(atac_cells)
    rna_len = len(rna_cells)
    
    #pair cells
    if(atac_len == rna_len):
        pair_list = np.vstack((atac_cells, rna_cells))
    if(atac_len < rna_len):
        pair_list = np.hstack((np.vstack((atac_cells, rna_cells[:atac_len])),
                               np.vstack((np.random.choice(atac_cells, size=rna_len-atac_len), rna_cells[atac_len:]))))
    if(rna_len < atac_len):
        pair_list = np.hstack((np.vstack((atac_cells[:rna_len], rna_cells)),
                               np.vstack((atac_cells[rna_len:], np.random.choice(rna_cells, size=atac_len-rna_len)))))

    if(add_fate and 'fate' in clone.columns):
        fate_curr = clone['fate'].values[0]
        fate_curr = np.array([fate_curr]*pair_list.shape[1]).reshape(1,-1)  
        return(np.vstack((pair_list, fate_curr)))
        
    elif(add_fate and 'fate' not in clone.columns):
        raise ValueError("add_fate set to True but 'fate' column not available in the clone table, please add clonal fates manually or with the tl.assign_fate function")
    else:
        return(pair_list)
        
def get_clone_celltag_mtx(ct_obj, sig_type="core"):
    """
    Builds a clone-by-CellTag matrix from the metric-filtered matrix in a CellTagData
    object, based on which CellTags are present in each clone.

    For each clone (from `ct_obj.clone_table`):
    - A sub-matrix of the metric-filtered matrix (`ct_obj.metric_mtx`) is extracted
      for cells belonging to that clone.
    - Depending on `sig_type`, a list of CellTags is selected:
        - "core": CellTags present in more than one cell of the clone.
        - "union": CellTags present in at least one cell of the clone.
    - Each clone’s chosen CellTags are accumulated.

    Finally, this information is converted into a sparse matrix via `table_to_spmtx`,
    returning a clone-by-CellTag matrix of ones (indicating presence of each CellTag
    in a particular clone).

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object, which must include `metric_mtx` and a
            `clone_table`.
        sig_type (str, optional):
            Determines which CellTags define the clone’s "signature":
            - "core": CellTags present in more than one cell of the clone.
            - "union": CellTags present in at least one cell of the clone.
            Defaults to "core".

    Returns:
        tuple:
            (sparse_mtx, row_labels, col_labels) as returned by `table_to_spmtx`, where:
                - row_labels are clone IDs.
                - col_labels are CellTag identifiers.
                - sparse_mtx is a clone-by-CellTag matrix of ones indicating presence.

    Raises:
        ValueError: If `ct_obj` is invalid or does not contain the required
            metric matrix (`metric_mtx`) or `clone_table`.
    """

    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")
        
    check_mtx_dict(ct_obj.metric_mtx)

    if not (isinstance(ct_obj.clone_table, pd.DataFrame)):
        raise ValueError("Clone table is either not available or not a DataFrame, please re-run tl.call_clones")

    clones = ct_obj.clone_table.copy()
    celltag_mat_met = ct_obj.metric_mtx['mtx'].copy()
    cells_met = ct_obj.metric_mtx["cells"].copy()
    celltags_met = ct_obj.metric_mtx["celltags"].copy()
    
    clone_id = np.empty([0,])
    clone_tag = np.empty([0,])

    for i,j in clones.groupby('clone.id'):

        #get clone_mtx
        clone_mtx_curr = celltag_mat_met[np.isin(cells_met,j['cell.bc']),]

        if(sig_type=="core"):
            ct_sig = celltags_met[(clone_mtx_curr.sum(axis=0) > 1).nonzero()[1]]

        elif(sig_type=="union"):
            ct_sig = celltags_met[(clone_mtx_curr.sum(axis=0) > 0).nonzero()[1]]

        clone_tag = np.hstack([clone_tag, ct_sig])
        clone_id = np.hstack([clone_id, np.ones_like(ct_sig, dtype=int)*i])


    return(table_to_spmtx(clone_id, clone_tag, np.ones_like(clone_id, dtype=int)))


def ident_sparse_clones(ct_obj, n_largest = 10, density_th = 0.2, plot=False, **kwargs):
    """
    Identifies the "sparse" clones among the largest clones in a given metadata table,
    defined by an edge density threshold. Optionally generates a scatter plot of clone
    size vs. edge density.

    Args:
        clone_info (pd.DataFrame):
            A DataFrame containing per-clone metadata, including columns:
            - 'clone.id'
            - 'size' (number of cells in each clone)
            - 'edge.den' (edge density of the clone subgraph)
        n_largest (int, optional):
            Number of top clones by size to consider for filtering. Defaults to 10.
        density_th (float, optional):
            Maximum edge density for a clone to be considered "sparse." Defaults to 0.2.
        plot (bool, optional):
            If True, returns a matplotlib Axes object with a scatter plot of clone size
            vs. edge density. Defaults to False.
        **kwargs:
            Additional keyword arguments passed to the plotting function (e.g., marker size).

    Returns:
        pd.DataFrame | tuple[None, matplotlib.axes.Axes]:
            - If any sparse clones are found, returns a DataFrame subset of
              `clone_info` containing only those sparse clones. If `plot=True`,
              also returns the Axes object.
            - If no sparse clones are found, returns `None`. If `plot=True`,
              returns `(None, Axes)`.

    Notes:
        - Sparse clones are defined here as clones that rank among the top
          `n_largest` by size but have `edge.den < density_th`.
        - The optional plotting is handled by `plot_size_by_den`.
    """
    
    if not (isinstance(ct_obj, CellTagData)):
        raise ValueError("Please provide a valid CellTagData object")

    if not (isinstance(ct_obj.clone_info, pd.DataFrame)):
        raise ValueError("Clone table is either not available or not a DataFrame, please re-run tl.call_clones")

    clone_info = ct_obj.clone_info.copy()
    
    clone_info_subset = clone_info.nlargest(n_largest, columns='size')
    clone_info_subset = clone_info_subset[clone_info_subset['edge.den'] < density_th].copy()

    if(len(clone_info_subset) == 0):
        print("No sparse clones found!")
        if(plot):
            ax=plot_size_by_den(clone_info, **kwargs)
            return(None, ax)
        return(None)

    if(plot):
        from .plotting import plot_size_by_den
        
        ax=plot_size_by_den(clone_info, red_clones=clone_info_subset['clone.id'].values, **kwargs)
        return(clone_info_subset, ax)
    return(clone_info_subset)

    

def fix_sparse_clones(ct_obj, sparse_ids = None):

    """
    Reassigns cells from "sparse" clones by splitting them into maximal cliques,
    then recombines all clones into a new clone table. Useful for refining
    clone assignments after initial clone calling.

    Specifically, for each clone in `ct_obj.clone_graph` whose index is in
    `sparse_ids` , we repeatedly extract the largest clique
    and mark those cells as a new clone until no edges remain.

    Args:
        ct_obj (CellTagData):
            A valid CellTagData object with a `clone_graph` attribute representing
            clonal subgraphs and a `clone_table`.
        sparse_ids (array-like | None, optional):
            List of clone IDs (1-based) to be split. If None, the function
            does nothing and returns immediately. Defaults to None.

    Returns:
        pd.DataFrame | None:
            - If `inplace=True`, updates `ct_obj.clone_table` with the newly rebuilt
              clone assignments and returns `None`.
            - Otherwise, returns a new clone table (pd.DataFrame) without modifying
              `ct_obj`.

    Raises:
        ValueError: If cell number checks fail or if `ct_obj` is not valid.

    Notes:
        - This function references an `inplace` check near the end, but there's no
          formal `inplace` argument in its signature. If you want in-place updates,
          consider adding `inplace=True` to the signature.
        - The final clone IDs are re-enumerated starting from 1.
    """

    if(isinstance(sparse_ids, type(None))):
        print("No sparse clones found")
        return()


    clone_graph = ct_obj.clone_graph

    new_clones = []
    edge_density = []
    og_clones = clone_graph.components()

    #define variables for cell number snaity check
    init_cells = sum([len(i) for i in og_clones])
    wasted_cells = 0
    new_cells = 0

    for i in range(len(og_clones)):

        #if sparse clone is encountered
        if(i in sparse_ids-1):
            idx_curr = i

            #extract clone
            sub_gr = clone_graph.induced_subgraph(og_clones[i])

            #extract maximum clique from clone and add to new_clones
            while sub_gr.ecount() > 0:
                new_idx = sub_gr.largest_cliques()[0]
                new_gr = sub_gr.induced_subgraph(new_idx)
                new_cb = new_gr.vs['cb']

                #add new cb to list
                new_clones.append(new_cb)

                #assert edge density is 1 and add to density list
                try:
                    assert(new_gr.density() == 1)
                except AssertionError:
                    print("Maximum clique density is less than 1, graph subsetting is incorrect")
                    return()

                edge_density.append([new_gr.density()]*len(new_cb))

                sub_gr.delete_vertices(new_idx)

            wasted_cells = wasted_cells + sub_gr.vcount()

        #add to clone list as normal if not sparse ID
        else:
            new_clones.append(clone_graph.induced_subgraph(og_clones[i]).vs['cb'])
            edge_density.append([clone_graph.induced_subgraph(og_clones[i]).density()]*len(og_clones[i]))

    #cell number sanity check
    new_cells = sum([len(i) for i in new_clones])

    try:
        assert(new_cells == (init_cells - wasted_cells))
    except AssertionError:
        print("Cell number sanity check failed!")
        return()

    clone_id = [[j+1]*len(i) for j,i in enumerate(new_clones)]
            
    #create and return clone table
    clone_table = pd.concat([pd.DataFrame((i,j,k), index = ['clone.id','cell.bc','edge.den']).T for i,j,k in zip(clone_id,new_clones,edge_density)])

    if inplace:
        ct_obj.clone_table = clone_table.copy()
    else:
        return(clone_table)